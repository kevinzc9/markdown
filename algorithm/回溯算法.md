# 知识点
1.递归与回溯相辅相成
2.回溯的本质是穷举，就算加上了剪枝效率也不高
3.回溯法的问题可以抽象为树形结构，结束即在叶子结点
4.使用递归的结构可以近似抽象为解决k层for循环的问题
# 代码模板

![[Pasted image 20240101202919.png]]

```
void backtracking(参数) {
    if (终止条件) {
        存放结果;
        return;
    }

    for (选择：本层集合中元素（树中节点孩子的数量就是集合的大小）) {
        处理节点;
        backtracking(路径，选择列表); // 递归
        回溯，撤销处理结果
    }
}
```

## 注意
1.在backtracking存放结果时往往涉及重新初始化数据结构进行存储(操作地址的思想)
2.每次的for循环的开始位置往往涉及到去重的操作
3.组合问题是否使用startIndex一般取决于是单集合问题还是多集合问题，前者用后者不用

## 优化方向
1.通过指定backtracking中的循环结束位置进行剪枝（组合）
2.通过指定在backtracking开始的判断中剪枝（组合III）

## 去重问题





# 题目

## 组合
https://leetcode.cn/problems/combinations/
![[Pasted image 20240102172238.png]]
注意从左到右依次取的思想，做到不重复出现组合
通过设置startIndex的思想实现每次递归从不同的起点开始遍历，从而避免重复
### 求解
未优化版本：
```
class Solution {

List<List<Integer>> res=new ArrayList<>();

LinkedList<Integer> path = new LinkedList<>();

  
public List<List<Integer>> combine(int n, int k) {

for(int i=1;i<=n;i++){

path.add(i);

backtracking(i,k,n);

path.remove(path.size()-1);

}

return res;

}

public void backtracking(int start,int k,int n){

if(path.size()==k){

res.add(new ArrayList<>(path));

return ;

}

for(int i=start+1;i<=n;i++){

path.add(i);

backtracking(i,k,n);

path.remove(path.size()-1);

}

  

}

}
```
优化版本：
```
class Solution {

List<List<Integer>> res=new ArrayList<>();

LinkedList<Integer> path = new LinkedList<>();


public List<List<Integer>> combine(int n, int k) {

for(int i=1;i<=n-k+1;i++){

path.add(i);

backtracking(i,k,n);

path.remove(path.size()-1);

}

return res;

}

public void backtracking(int start,int k,int n){

if(path.size()==k){

res.add(new ArrayList<>(path));

return ;

}

for(int i=start+1;i<=n - (k - path.size()) + 1;i++){

path.add(i);

backtracking(i,k,n);

path.remove(path.size()-1);

}

  

}

}
```


### 优化
#### 1.剪枝
优化在每次循环剩下的元素总数小于k时，可以直接剪枝
即：for循环在寻找起点的时候要有一个范围，如果这个起点到集合终止之间的元素已经不够 题目要求的k个元素了，就没有必要搜索了**。
```
for (int i = startIndex; i <= n - (k - path.size()) + 1; i++)
```
![[Pasted image 20240102172745.png]]

## 组合总和III
https://leetcode.cn/problems/combination-sum-iii/description/
![[Pasted image 20240103100640.png]]

```
class Solution {

List<List<Integer>> res=new ArrayList<>();

List<Integer> path=new ArrayList<>();

int currentSum=0;

public List<List<Integer>> combinationSum3(int k, int n) {

for(int i=1;i<=9;i++){

path.add(i);

currentSum+=i;

backtracking(k,n,i);

currentSum-=i;

path.remove(path.size()-1);

}

return res;

}

public void backtracking(int k,int n,int start){

if(path.size()==k){

if(currentSum==n){

res.add(new ArrayList<>(path));

}

return ;

}

for(int i=start+1;i<=9;i++){

path.add(i);

currentSum+=i;

backtracking(k,n,i);

path.remove(path.size()-1);

currentSum-=i;

}
}

}
```

```
class Solution {

List<List<Integer>> res=new ArrayList<>();

List<Integer> path=new ArrayList<>();

int currentSum=0;

public List<List<Integer>> combinationSum3(int k, int n) {

for(int i=1;i<=9;i++){

path.add(i);

currentSum+=i;

backtracking(k,n,i);

currentSum-=i;

path.remove(path.size()-1);

}

return res;

}

public void backtracking(int k,int n,int start){

if(path.size()==k){

if(currentSum==n){

res.add(new ArrayList<>(path));

}

return ;

}

for(int i=start+1;i<=Math.min(9,n-currentSum);i++){

path.add(i);

currentSum+=i;

backtracking(k,n,i);

path.remove(path.size()-1);

currentSum-=i;

  

}

  

}

}
```

## 电话号码的字母组合(多集合问题)
https://leetcode.cn/problems/letter-combinations-of-a-phone-number/description/
```java
class Solution {

List<String> res=new ArrayList<>();

public List<String> letterCombinations(String digits) {

if(digits.length()==0) return res;

Map<Character, String> phoneMap = new HashMap<Character, String>() {{

put('2', "abc");

put('3', "def");

put('4', "ghi");

put('5', "jkl");

put('6', "mno");

put('7', "pqrs");

put('8', "tuv");

put('9', "wxyz");

}};

backtracking(digits,0,new StringBuilder(),phoneMap);

return res;

  

}

public void backtracking(String digits,int index,StringBuilder currentS,Map<Character, String> phoneMap){

if(index==digits.length()){

res.add(currentS.toString());

return ;

}

String thisDict=phoneMap.get(digits.charAt(index));

for(int j=0;j<thisDict.length();j++){

currentS.append(thisDict.charAt(j));

backtracking(digits,index+1,currentS,phoneMap);

currentS.deleteCharAt(currentS.length()-1);

}

}

}
```

注意使用StringBuilder进行字符串的传递（java中的String是不可变的）

## 组合总和
https://leetcode.cn/problems/combination-sum/
```java
class Solution {

List<List<Integer>> res=new ArrayList<>();

List<Integer> path=new ArrayList<>();

public List<List<Integer>> combinationSum(int[] candidates, int target) {

backtracking(candidates,target,0,0);

return res;

}

public void backtracking(int []candidates,int target,int current,int start){

if(current>target) return ;

if(current==target){

res.add(new ArrayList<>(path));

return ;

}

for(int i=start;i<candidates.length;i++){

path.add(candidates[i]);

current+=candidates[i];

backtracking(candidates,target,current,i);

current-=candidates[i];

path.remove(path.size()-1);

}

}

}
```
![[Pasted image 20240103181744.png]]
注意限制startIndex来避免访问到之前的元素
## 组合总和II
https://leetcode.cn/problems/combination-sum-ii/
本题的难点在于区别2中：集合有重复元素，但还不能有重复的组合。